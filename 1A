#define _GNU_SOURCE
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <dirent.h>
#include <fnmatch.h>
#include <signal.h>
#include <pwd.h>
#include <sys/inotify.h>
#include <openssl/sha.h>
#include <errno.h>

#define TEMPLATE_FILE "template.tbl"
#define BUFFER_SIZE 4096
#define MAX_PATTERNS 100
#define MAX_PATH 1024

char *patterns[MAX_PATTERNS];
int pattern_count = 0;
char password_hash[65]; // SHA256 produces 64-character hash
char current_directory[MAX_PATH];
pid_t monitor_pid = 0;

// Функция для вычисления хеша SHA256
void compute_sha256(const char *input, char *output) {
    unsigned char hash[SHA256_DIGEST_LENGTH];
    SHA256_CTX sha256;
    SHA256_Init(&sha256);
    SHA256_Update(&sha256, input, strlen(input));
    SHA256_Final(hash, &sha256);
    
    for(int i = 0; i < SHA256_DIGEST_LENGTH; i++) {
        sprintf(output + (i * 2), "%02x", hash[i]);
    }
    output[64] = 0;
}

// Проверка прав root
int is_root_user() {
    return geteuid() == 0;
}

// Защита файла - устанавливаем права только для root
int protect_file(const char *filename) {
    if(chmod(filename, S_IRUSR | S_IWUSR) != 0) {
        perror("chmod protect");
        return 0;
    }
    
    if(chown(filename, 0, 0) != 0) { // Изменяем владельца на root
        perror("chown protect");
        return 0;
    }
    return 1;
}

// Снятие защиты с файла
int unprotect_file(const char *filename) {
    struct stat st;
    if(stat(filename, &st) != 0) {
        perror("stat unprotect");
        return 0;
    }
    
    // Восстанавливаем стандартные права (644)
    if(chmod(filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) != 0) {
        perror("chmod unprotect");
        return 0;
    }
    
    // Возвращаем владельца оригинальному пользователю
    uid_t original_uid = getuid();
    gid_t original_gid = getgid();
    if(chown(filename, original_uid, original_gid) != 0) {
        perror("chown unprotect");
        return 0;
    }
    return 1;
}

// Проверка пароля
int verify_password() {
    char password[256];
    printf("Введите пароль: ");
    fflush(stdout);
    
    if(fgets(password, sizeof(password), stdin) == NULL) {
        return 0;
    }
    
    // Убираем символ новой строки
    password[strcspn(password, "\n")] = 0;
    
    char input_hash[65];
    compute_sha256(password, input_hash);
    
    return strcmp(input_hash, password_hash) == 0;
}

// Создание файла шаблонов
int create_template_file() {
    char password[256];
    printf("Создание файла template.tbl...\n");
    printf("Придумайте пароль: ");
    fflush(stdout);
    
    if(fgets(password, sizeof(password), stdin) == NULL) {
        return 0;
    }
    
    password[strcspn(password, "\n")] = 0;
    compute_sha256(password, password_hash);
    
    FILE *file = fopen(TEMPLATE_FILE, "w");
    if(!file) {
        perror("fopen create");
        return 0;
    }
    
    fprintf(file, "%s\n", password_hash);
    fprintf(file, "*.txt\n");
    fclose(file);
    
    return 1;
}

// Загрузка файла шаблонов
int load_template_file() {
    FILE *file = fopen(TEMPLATE_FILE, "r");
    if(!file) {
        return 0;
    }
    
    if(fgets(password_hash, sizeof(password_hash), file) == NULL) {
        fclose(file);
        return 0;
    }
    
    // Убираем символ новой строки
    password_hash[strcspn(password_hash, "\n")] = 0;
    
    pattern_count = 0;
    char line[256];
    while(fgets(line, sizeof(line), file) && pattern_count < MAX_PATTERNS) {
        line[strcspn(line, "\n")] = 0;
        if(strlen(line) > 0) {
            patterns[pattern_count] = strdup(line);
            pattern_count++;
        }
    }
    
    fclose(file);
    return 1;
}

// Проверка соответствия файла шаблонам
int match_pattern(const char *filename) {
    for(int i = 0; i < pattern_count; i++) {
        if(fnmatch(patterns[i], filename, 0) == 0) {
            return 1;
        }
    }
    return 0;
}

// Мониторинг директории
void monitor_directory() {
    int fd = inotify_init();
    if(fd < 0) {
        perror("inotify_init");
        exit(1);
    }
    
    int wd = inotify_add_watch(fd, ".", IN_CREATE | IN_MOVED_TO | IN_DELETE | IN_MOVE_SELF);
    if(wd < 0) {
        perror("inotify_add_watch");
        close(fd);
        exit(1);
    }
    
    char buffer[BUFFER_SIZE];
    while(1) {
        ssize_t length = read(fd, buffer, BUFFER_SIZE);
        if(length < 0) {
            perror("read inotify");
            break;
        }
        
        char *ptr = buffer;
        while(ptr < buffer + length) {
            struct inotify_event *event = (struct inotify_event *)ptr;
            
            if(event->len && (event->mask & (IN_CREATE | IN_MOVED_TO))) {
                if(match_pattern(event->name)) {
                    printf("Обнаружен защищенный файл: %s - удаление...\n", event->name);
                    
                    // Пытаемся удалить файл
                    for(int i = 0; i < 10; i++) {
                        if(unlink(event->name) == 0) {
                            break;
                        }
                        usleep(200000); // 200ms
                    }
                }
            }
            
            ptr += sizeof(struct inotify_event) + event->len;
        }
    }
    
    close(fd);
}

// Включение защиты
void enable_protection() {
    if(!protect_file(TEMPLATE_FILE)) {
        printf("Ошибка защиты файла template.tbl\n");
        return;
    }
    
    // Защищаем существующие файлы
    DIR *dir = opendir(".");
    if(dir) {
        struct dirent *entry;
        while((entry = readdir(dir)) != NULL) {
            if(entry->d_type == DT_REG && match_pattern(entry->d_name)) {
                protect_file(entry->d_name);
            }
        }
        closedir(dir);
    }
    
    printf("Защита включена\n");
    
    // Запускаем мониторинг в дочернем процессе
    pid_t pid = fork();
    if(pid == 0) {
        // Дочерний процесс
        monitor_directory();
        exit(0);
    } else if(pid > 0) {
        monitor_pid = pid;
    } else {
        perror("fork");
    }
}

// Выключение защиты
void disable_protection() {
    if(monitor_pid > 0) {
        kill(monitor_pid, SIGTERM);
        monitor_pid = 0;
    }
    
    if(!unprotect_file(TEMPLATE_FILE)) {
        printf("Ошибка снятия защиты с template.tbl\n");
        return;
    }
    
    // Восстанавливаем доступ к файлам
    DIR *dir = opendir(".");
    if(dir) {
        struct dirent *entry;
        while((entry = readdir(dir)) != NULL) {
            if(entry->d_type == DT_REG && match_pattern(entry->d_name)) {
                unprotect_file(entry->d_name);
            }
        }
        closedir(dir);
    }
    
    printf("Защита выключена\n");
}

// Освобождение памяти
void cleanup() {
    for(int i = 0; i < pattern_count; i++) {
        free(patterns[i]);
    }
}

int main() {
    atexit(cleanup);
    
    if(!getcwd(current_directory, sizeof(current_directory))) {
        perror("getcwd");
        return 1;
    }
    
    if(!is_root_user()) {
        printf("Для запуска программы необходимы права root\n");
        return 1;
    }
    
    if(access(TEMPLATE_FILE, F_OK) != 0) {
        if(!create_template_file()) {
            printf("Ошибка создания файла template.tbl\n");
            return 1;
        }
    } else {
        if(!load_template_file()) {
            printf("Ошибка чтения файла template.tbl\n");
            return 1;
        }
    }
    
    if(!verify_password()) {
        printf("Неправильный пароль\n");
        return 1;
    }
    
    char action[10];
    printf("Выберите действие:\n0 - выключить защиту\n1 - включить защиту\n");
    
    if(fgets(action, sizeof(action), stdin) == NULL) {
        return 1;
    }
    
    if(strcmp(action, "1\n") == 0) {
        enable_protection();
    } else if(strcmp(action, "0\n") == 0) {
        disable_protection();
    } else {
        printf("Неверный выбор\n");
        return 1;
    }
    
    printf("\nДля закрытия программы нажмите Enter\n");
    getchar();
    
    if(monitor_pid > 0) {
        kill(monitor_pid, SIGTERM);
    }
    
    return 0;
}
